#pragma once

#ifndef GLFW_INCLUDE_VULKAN
#define GLFW_INCLUDE_VULKAN
#endif
#include <GLFW/glfw3.h>

/* The perspective projection matrix generated by GLM will use the OpenGL
 * depth range of -1.0 to 1.0 by default. We need to configure it to use
 * the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE
 * definition. */
#ifndef GLM_FORCE_DEPTH_ZERO_TO_ONE
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#endif
#ifndef GLM_FORCE_RADIANS
#define GLM_FORCE_RADIANS
#endif

#include <glm/glm.hpp>

#include <cstdint>
#include <string>
#include <vector>
#include <array>
#include <optional>
#include <unordered_map>

#include "Namespace.hpp"
#include "Camera.hpp"
#include "VulkanHelper.hpp"

NAMESPACE_BEGIN(GLOBAL_NAMESPACE)

class App
{
  public:
  void Run();

  protected:
  /* App */void InitWindow();

  /* App */void InitVulkan();

  /* App */void MainLoop();

  /* App */void Draw();

  /* App */void Destroy();

  protected:
  /* App Helper */void UpdateUniformBuffer(uint32_t CurrentImage);

  //Recreate the swapchain and all the objects depending on it, called when resizing.
  /* App Helper */void RecreateSwapChainAndRelevantObject();

  //Destroy the objects that are to be recreated in the "RecreateSwapChain()", called when resizing.
  /* App Helper */void DestroySwapChainAndRelevantObject();

  //Recreate the drawing command buffer, called when display mode or cull mode is changed.
  /* App Helper */void RecreateDrawingCommandBuffer();

  protected:
  /* Vulkan Init */void CreateInstance();

  /* Vulkan Init */void SetupDebugMessenger();

  /* Vulkan Init */void CreateSurface();

  /* Vulkan Init */void SelectPhysicalDevice();

  /* Vulkan Init */void CreateLogicalDevice();

  /* Vulkan Init */void CreateSwapChain();

  /* Vulkan Init */void CreateSwapChainImageViews();

  /* Vulkan Init */void CreateRenderPass();

  /* Vulkan Init */void CreateDescriptorSetLayout();

  /* Vulkan Init */void CreateGraphicsPipeline();

  /* Vulkan Init */void CreateCommandPool();

  /* Vulkan Init */void CreateColorResource();

  /* Vulkan Init */void CreateDepthResource();

  /* Vulkan Init */void CreateFramebuffers();

  /* Vulkan Init */void LoadAndCreateTextures();

  /* Vulkan Init */void LoadObjModel();

  /* Vulkan Init */void CreateVertexBuffer();

  /* Vulkan Init */void CreateIndexBuffer();

  /* Vulkan Init */void CreateMvpUniformBuffer();

  /* Vulkan Init */void CreateLightUniformBuffer();

  /* Vulkan Init */void CreateMaterialUniformBuffer();

  /* Vulkan Init */void CreateDescriptorPool();

  /* Vulkan Init */void CreateDescriptorSets();

  /* Vulkan Init */void CreateDrawingCommandBuffers();

  /* Vulkan Init */void CreateSyncObjects();

  protected:
  /* Callback */static VKAPI_ATTR VkBool32 VKAPI_CALL DebugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT MessageSeverity, VkDebugUtilsMessageTypeFlagsEXT MessageType,
                                                                     const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData);

  /* Callback */static void FramebufferResizeCallback(GLFWwindow* pWindow, int Width, int Height);

  /* Callback */static void MouseButtonCallback(GLFWwindow* pWindow, int Button, int Action, int Mods);

  /* Callback */static void MousePositionCallback(GLFWwindow* pWindow, double X, double Y);

  /* Callback */static void MouseScrollCallback(GLFWwindow* pWindow, double OffsetX, double OffsetY);

  /* Callback */static void KeyboardCallback(GLFWwindow* pWindow, int Key, int ScanCode, int Action, int Mods);

  /* Helper */static std::vector<char> ReadFile(const std::string& Filename);

  protected: //App
  GLFWwindow* m_pWindow = nullptr;
  uint32_t m_InitWidth = WINDOW_INIT_WIDTH;
  uint32_t m_InitHeight = WINDOW_INIT_HEIGH;
  std::string m_Title = "Vulky";
  std::string m_AppName = "VulkanApp";
  std::string m_EngineName = "VulkanEngine";
  std::string m_GpuName = "";
  bool m_bFramebufferResized = false;
  double m_FPS = 0.0;

  protected: //Vulkan pipeline
#ifdef NDEBUG
  const bool m_bEnableValidationLayers = false;
#else
  const bool m_bEnableValidationLayers = true;
#endif
  const std::vector<const char*> m_ValidationLayers = {"VK_LAYER_LUNARG_standard_validation"};
  const std::vector<const char*> m_DeviceExtensions = {VK_KHR_SWAPCHAIN_EXTENSION_NAME};

  const std::string m_VertexShaderPath = "Shaders/Shader.vert.spv";
  const std::string m_FragmentShaderPath = "Shaders/Shader.frag.spv";

  VkDebugUtilsMessengerEXT m_DebugMessenger = VK_NULL_HANDLE;
  VkSurfaceKHR m_Surface = VK_NULL_HANDLE;

  VkInstance m_Instance = VK_NULL_HANDLE;
  //This object will be implicitly destroyed when the "VkInstance" is destroyed.
  VkPhysicalDevice m_PhysicalDevice = VK_NULL_HANDLE;

  VkDevice m_Device = VK_NULL_HANDLE;
  //Device queues are implicitly destroyed when the device is destroyed.
  VkQueue m_GraphicsQueue = VK_NULL_HANDLE;
  VkQueue m_PresentQueue = VK_NULL_HANDLE;

  SwapChainInfo m_SwapChainInfo;

  VkRenderPass m_RenderPass = VK_NULL_HANDLE;
  VkPipelineLayout m_PipelineLayout = VK_NULL_HANDLE;

  enum GRAPHICS_PIPELINE_TYPE
  {
    GRAPHICS_PIPELINE_TYPE_FILL = 0b1,
    GRAPHICS_PIPELINE_TYPE_WIREFRAME = 0b10,
    GRAPHICS_PIPELINE_TYPE_POINT = 0b100,
    GRAPHICS_PIPELINE_TYPE_FRONT_CULL = 0b1000,
    GRAPHICS_PIPELINE_TYPE_BACK_CULL = 0b10000,
    GRAPHICS_PIPELINE_TYPE_NONE_CULL = 0b100000,
  };

  std::unordered_map<int, const char*> m_GraphicsPipelinesDescription =
  {
    {GRAPHICS_PIPELINE_TYPE_FILL | GRAPHICS_PIPELINE_TYPE_FRONT_CULL, "Fill & Front Cull"},
    {GRAPHICS_PIPELINE_TYPE_WIREFRAME | GRAPHICS_PIPELINE_TYPE_FRONT_CULL, "Wireframe & Front Cull"},
    {GRAPHICS_PIPELINE_TYPE_POINT | GRAPHICS_PIPELINE_TYPE_FRONT_CULL, "Point & Front Cull"},

    {GRAPHICS_PIPELINE_TYPE_FILL | GRAPHICS_PIPELINE_TYPE_BACK_CULL, "Fill & Back Cull"},
    {GRAPHICS_PIPELINE_TYPE_WIREFRAME | GRAPHICS_PIPELINE_TYPE_BACK_CULL, "Wireframe & Back Cull"},
    {GRAPHICS_PIPELINE_TYPE_POINT | GRAPHICS_PIPELINE_TYPE_BACK_CULL, "Point & Back Cull"},

    {GRAPHICS_PIPELINE_TYPE_FILL | GRAPHICS_PIPELINE_TYPE_NONE_CULL, "Fill & None Cull"},
    {GRAPHICS_PIPELINE_TYPE_WIREFRAME | GRAPHICS_PIPELINE_TYPE_NONE_CULL, "Wireframe & None Cull"},
    {GRAPHICS_PIPELINE_TYPE_POINT | GRAPHICS_PIPELINE_TYPE_NONE_CULL, "Point & None Cull"}
  };

  std::unordered_map<int, VkPipeline> m_GraphicsPipelines;
  int m_GraphicsPipelineDisplayMode = GRAPHICS_PIPELINE_TYPE_FILL;
  int m_GraphicsPipelineCullMode = GRAPHICS_PIPELINE_TYPE_NONE_CULL;

  VkCommandPool m_CommandPool = VK_NULL_HANDLE;
  //Command buffers will be automatically freed when their command pool is destroyed.
  std::vector<VkCommandBuffer> m_DrawingCommandBuffers;

  const int m_MaxFramesInFlights = 2;
  std::vector<VkSemaphore> m_ImageAvailableSemaphores;
  std::vector<VkSemaphore> m_RenderFinishedSemaphores;
  std::vector<VkFence> m_InFlightFences;
  size_t m_CurrentFrame = 0;

  protected: //Mesh
  struct Vertex
  {
    glm::vec3 Position;
    glm::vec3 Color;
    glm::vec3 Normal;
    glm::vec3 Tangent;
    glm::vec2 TexCoord;

    static VkVertexInputBindingDescription GetBindingDescription();
    static std::array<VkVertexInputAttributeDescription, 5> GetAttributeDescription();
  };

  struct VertexHash {size_t operator()(const Vertex& Rhs) const;};

  struct VertexEqual {bool operator()(const Vertex& Lhs, const Vertex& Rhs) const;};

  const std::string m_ModelPath = "Models/Cerberus.obj";
  std::vector<Vertex> m_Vertices;
  std::vector<uint32_t> m_Indices;

  size_t m_VertexNum = 0;
  size_t m_FacetNum = 0;

  BufferInfo m_VertexBuffer;
  BufferInfo m_IndexBuffer;

  protected: //UBO
  struct MvpUniformBufferObject
  {
    alignas(16) glm::mat4 Model;
    alignas(16) glm::mat4 ModelInvTranspose;
    alignas(16) glm::mat4 View;
    alignas(16) glm::mat4 Projection;
  };

  static const uint32_t m_LightNum = 8;
  struct LightUniformBufferObject
  {
    alignas(16) glm::vec4 LightPosition[m_LightNum];
    alignas(16) glm::vec4 LightColor[m_LightNum];
    alignas(16) glm::vec3 ViewPosition;
  };

  struct MaterialUniformBufferObject
  {
    alignas(16) glm::vec4 Albedo;
    alignas(4) float Metallic;
    alignas(4) float Roughness;
    alignas(4) float Ao;
  };

  VkDescriptorSetLayout m_DescriptorSetLayout = VK_NULL_HANDLE;
  std::vector<BufferInfo> m_MvpUniformBuffers;
  std::vector<BufferInfo> m_LightUniformBuffers;
  std::vector<BufferInfo> m_MaterialUniformBuffers;

  VkDescriptorPool m_DescriptorPool = VK_NULL_HANDLE;
  //Descriptor sets will be automatically freed when the descriptor pool is destroyed.
  std::vector<VkDescriptorSet> m_DescriptorSets;

  protected: //Texture
  const std::string m_AlbedoTexturePath = "Textures/Cerberus/Cerberus_A.png";
  TextureInfo m_AlbedoTexture;

  const std::string m_NormalTexturePath = "Textures/Cerberus/Cerberus_N.png";
  TextureInfo m_NormalTexture;

  const std::string m_MetallicTexturePath = "Textures/Cerberus/Cerberus_M.png";
  TextureInfo m_MetallicTexture;

  const std::string m_RoughnessTexturePath = "Textures/Cerberus/Cerberus_R.png";
  TextureInfo m_RoughnessTexture;

  const std::string m_AoTexturePath = "Textures/Cerberus/Cerberus_AO.png";
  TextureInfo m_AoTexture;

  protected: //Camera
  Camera m_Camera;
  int m_MouseButton = -1;
  int m_MouseAction = -1;
};

NAMESPACE_END